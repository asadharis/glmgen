% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lattice.R
\name{fusedLattice}
\alias{fusedLattice}
\title{Fit a fused lasso over a lattice}
\usage{
fusedLattice(y, weights, edgeWeights = NULL, lambda = NULL, nlambda = 20L,
  lambdaMinRatio = 1e-05, E = NULL, c = NULL, latticeType = c("square",
  "hex", "cube"), rho = 1, eps = 0.01, maxIter = 20, beta0 = NULL,
  method = c("prox", "dp"), verbose = FALSE)
}
\arguments{
\item{y}{the observed data points, as a matrix or 3 dimensional array.
See Details for how this is interpreted for a hexagonal lattice.}

\item{weights}{optional sample weights. If provided, it must be the same length
as \code{y}; it can be a vector, matrix, or array. Data will be
assumed to be missing if either \code{y} or \code{weights} is
\code{NA}. If missing, the weights will be assumed to be constant
(unity) across all samples.}

\item{edgeWeights}{optional edge weights. See Details for how to supply these.}

\item{lambda}{a sequence of lambda values at which to produce a fit. Can be
left blank (highly recommended for general use), at which point
the algorithm will determine appropriate lambda values.}

\item{nlambda}{if \code{lambda} is missing, this determines the number of lambda
values dynamically constructed by the algorithm.}

\item{lambdaMinRatio}{if \code{lambda} is missing, this determines the ratio between the
largest and smallest \code{lambda} values. The values are evenly
spaced on a log scale, so this ratio should typically be set fairly
small.}

\item{E}{an optional matrix for supplying a set of linear constraints on
the output. Columns corrispond to the (vectorised version of) the
data samples, and each row to a given constraint. See Details for
more information.}

\item{c}{an optional vector with one element per row of \code{E}. Gives
the right hand side of the constraint. If missing but \code{E}
is supplied, this will be assumed to be a vector of zeros.}

\item{latticeType}{the type of lattice to use. Will default to \code{square} if
\code{y} is a matrix and \code{cube} if it is a 3 dimensional
array.}

\item{rho}{a positive number used as a tuning parameter for the ADMM}

\item{eps}{stopping parameter for the iterative algorithm.}

\item{maxIter}{maximal number of iterations for the algorithm.}

\item{beta0}{initial starting point for the algorithm; if \code{NULL}, the
default, the mean value of all inputs is used.}

\item{method}{method used to solve the 1D chains in the ADMM algorithms.
Currently either \code{dp} for Johnson's dynamic program or
\code{prox} for proximal optimization method for Barbero and
Suvrit.}

\item{verbose}{logical. Should the function print out intermediate results
as it is running.}
}
\value{
an object of class 'glmgen', with methods for extracting
  coefficents and predictions.
}
\description{
Calculates the fused lasso over a 2 dimensional square,
hexagonal lattice, or 3 dimensional cube. Allows for an
optional linear constraint on the result, seamlessly
handles missing data, and allows for an optional set of
observation weights.
}
\details{
When \code{latticeType} is set to \code{hex}, the algorithm
  will assume the data are distributed over a 2 dimensional
  hexagonal lattice. The coordinate system used assumes that
  even rows are offset by a factor of negative one half from
  the odd rows. Other patterns can be achieved by inserting
  \code{NA} values in over this grid and shifting data
  appropriately.

  The \code{E} and \code{c} can be supplied to enforce the
  constraint Eb=c, where b is a vector of coefficients
  corrisponding to the vectorised version of \code{y}
  (i.e., \code{as.numeric(y)}). If \code{c} is missing, it will
  be assumed to be a vector of zeros.
}
\examples{

 set.seed(1)

 # Over a 20x10 grid
 y = matrix(rnorm(200),20,10)
 y[1:5,1:5] = y[1:5,1:5] + 2
 z = fusedLattice(y, lambda = 3, eps=0.0001, maxIter=100)
 print(matrix(z$beta, 20, 10))
 z = fusedLattice(y, lambda = 0.0001, eps=0.0001, maxIter=100)
 print(round(matrix(z$beta, 20, 10) - y),3)

 # Linear constraint and missing values
 y = matrix(rnorm(8*12),8,12)
 y[1:5,1:5] = y[1:5,1:5] + 2
 y[2,10] = NA
 E = Matrix::Matrix(0,2,length(y))
 E[1,1] = 1
 E[1,2] = -1
 E[2,9] = 1
 E[2,11] = -1
 c = c(0,1)

 z = fusedLattice(y, lambda = 0.00001, eps=0.0001, maxIter=100,
                  latticeType="square", E=E, c=c)

 # 3D Lattice
 y = array(rnorm(3 * 4 * 5),dim=c(5,4,3))
 z = fusedLattice(y, lambda = 30, latticeType="cube")
 array(z$beta, dim=dim(y))
 z = fusedLattice(y, lambda = 0.0001, latticeType="cube")
 array(z$beta, dim=dim(y)) - y

}
\references{
Johnson, Nicholas A. "A Dynamic Programming Algorithm for the
   Fused Lasso and L0-Segmentation." Journal of Computational and
   Graphical Statistics 22.2 (2013): 246-260.

  Barbero, Alvaro, and Suvrit Sra. "Modular proximal optimization
   for multidimensional total-variation regularization." arXiv
   preprint arXiv:1411.0589 (2014).

  Barbero, Alvaro, and Suvrit Sra. "Fast Newton-type methods for
   total variation regularization." Proceedings of the 28th
   International Conference on Machine Learning (ICML-11). 2011.
}
\author{
Taylor Arnold
}
